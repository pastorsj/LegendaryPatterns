digraph G{
	node [shape = "record"]
Collections [
	label = "{Collections|
	- BINARYSEARCH_THRESHOLD: int\l
	- REVERSE_THRESHOLD: int\l
	- SHUFFLE_THRESHOLD: int\l
	- FILL_THRESHOLD: int\l
	- ROTATE_THRESHOLD: int\l
	- COPY_THRESHOLD: int\l
	- REPLACEALL_THRESHOLD: int\l
	- INDEXOFSUBLIST_THRESHOLD: int\l
	- r: Random\l
	+ EMPTY_SET: Set\l
	+ EMPTY_LIST: List\l
	+ EMPTY_MAP: Map\l
	|
	+ rotate(List\<*\>, int) : void\l
	+ emptyIterator(T, :, Object\>, () : \<Object, Iterator\<TT\>\l
	+ emptyNavigableSet(E, :, Object\>, () : \<Object, NavigableSet\<TE\>\l
	+ newSetFromMap(E, :, Object\>, (, Map\<TE, Boolean\>) : \<Object, Map\<TE, Boolean\>, Set\<TE\>\l
	+ indexOfSubList(List\<*\>, List\<*\>) : int\l
	+ frequency(Collection\<*\>, Object) : int\l
	+ unmodifiableCollection(T, :, Object\>, (, Collection\<+TT\>) : \<Object, Collection\<+TT\>, Collection\<TT\>\l
	+ checkedNavigableSet(E, :, Object\>, (, NavigableSet\<TE\>, Class\<TE\>) : \<Object, NavigableSet\<TE\>, Class\<TE\>, NavigableSet\<TE\>\l
	+ checkedSortedMap(K, :, Object, void, :, Object\>, (, SortedMap\<TK, T, void\>, Class\<TK\>, Class\<TV\>) : \<Object, Object, SortedMap\<TK, TV\>, Class\<TK\>, Class\<TV\>, SortedMap\<TK, TV\>\l
	- indexedBinarySearch(T, :, Object\>, (, List\<+TT\>, T, T, Comparator\<-TT\>) : int\l
	+ checkedSortedSet(E, :, Object\>, (, SortedSet\<TE\>, Class\<TE\>) : \<Object, SortedSet\<TE\>, Class\<TE\>, SortedSet\<TE\>\l
	+ checkedNavigableMap(K, :, Object, void, :, Object\>, (, NavigableMap\<TK, T, void\>, Class\<TK\>, Class\<TV\>) : \<Object, Object, NavigableMap\<TK, TV\>, Class\<TK\>, Class\<TV\>, NavigableMap\<TK, TV\>\l
	+ singletonMap(K, :, Object, void, :, Object\>, (, T, K, T, void) : \<Object, Object, \>(TK, TV, Map\<TK, TV\>\l
	+ disjoint(Collection\<*\>, Collection\<*\>) : boolean\l
	+ enumeration(T, :, Object\>, (, Collection\<TT\>) : \<Object, Collection\<TT\>, Enumeration\<TT\>\l
	- iteratorBinarySearch(T, :, Object\>, (, List\<+TT\>, T, T, Comparator\<-TT\>) : int\l
	+ unmodifiableNavigableSet(T, :, Object\>, (, NavigableSet\<TT\>) : \<Object, NavigableSet\<TT\>, NavigableSet\<TT\>\l
	+ emptyNavigableMap(K, :, Object, void, :, Object\>, () : \<Object, Object, NavigableMap\<TK, TV\>\l
	+ emptyEnumeration(T, :, Object\>, () : \<Object, Enumeration\<TT\>\l
	+ synchronizedNavigableMap(K, :, Object, void, :, Object\>, (, NavigableMap\<TK, T, void\>) : \<Object, Object, NavigableMap\<TK, TV\>, NavigableMap\<TK, TV\>\l
	 singletonIterator(E, :, Object\>, (, T, E) : \<Object, \>(TE, Iterator\<TE\>\l
	+ synchronizedSortedSet(T, :, Object\>, (, SortedSet\<TT\>) : \<Object, SortedSet\<TT\>, SortedSet\<TT\>\l
	- swap(Object[], int, int) : void\l
	+ checkedCollection(E, :, Object\>, (, Collection\<TE\>, Class\<TE\>) : \<Object, Collection\<TE\>, Class\<TE\>, Collection\<TE\>\l
	+ sort(T, :, Object\>, (, List\<TT\>, Comparator\<-TT\>) : void\l
	+ fill(T, :, Object\>, (, List\<-TT\>, T, T) : void\l
	+ synchronizedNavigableSet(T, :, Object\>, (, NavigableSet\<TT\>) : \<Object, NavigableSet\<TT\>, NavigableSet\<TT\>\l
	+ list(T, :, Object\>, (, Enumeration\<TT\>) : \<Object, Enumeration\<TT\>, ArrayList\<TT\>\l
	 eq(Object, Object) : boolean\l
	+ unmodifiableMap(K, :, Object, void, :, Object\>, (, Map\<+TK, +, T, void\>) : \<Object, Object, Map\<+TK, +TV\>, Map\<TK, TV\>\l
	 zeroLengthArray(T, :, Object\>, (, Class\<TT\>) : \<Object, Class\<TT\>, )[TT\l
	+ unmodifiableList(T, :, Object\>, (, List\<+TT\>) : \<Object, List\<+TT\>, List\<TT\>\l
	+ lastIndexOfSubList(List\<*\>, List\<*\>) : int\l
	- rotate1(T, :, Object\>, (, List\<TT\>, int) : void\l
	- rotate2(List\<*\>, int) : void\l
	+ asLifoQueue(T, :, Object\>, (, Deque\<TT\>) : \<Object, Deque\<TT\>, Queue\<TT\>\l
	+ synchronizedSortedMap(K, :, Object, void, :, Object\>, (, SortedMap\<TK, T, void\>) : \<Object, Object, SortedMap\<TK, TV\>, SortedMap\<TK, TV\>\l
	+ emptySet(T, :, Object\>, () : \<Object, Set\<TT\>\l
	+ reverseOrder(T, :, Object\>, (, Comparator\<TT\>) : \<Object, Comparator\<TT\>, Comparator\<TT\>\l
	 synchronizedCollection(T, :, Object\>, (, Collection\<TT\>, Object) : \<Object, Collection\<TT\>, Object, Collection\<TT\>\l
	+ binarySearch(T, :, Object\>, (, List\<+TT\>, T, T, Comparator\<-TT\>) : int\l
	+ replaceAll(T, :, Object\>, (, List\<TT\>, T, T, T, T) : boolean\l
	+ checkedMap(K, :, Object, void, :, Object\>, (, Map\<TK, T, void\>, Class\<TK\>, Class\<TV\>) : \<Object, Object, Map\<TK, TV\>, Class\<TK\>, Class\<TV\>, Map\<TK, TV\>\l
	+ emptyList(T, :, Object\>, () : \<Object, List\<TT\>\l
	+ min(T, :, Object\>, (, Collection\<+TT\>, Comparator\<-TT\>) : \<Object, Collection\<+TT\>, Comparator\<-TT\>, )TT\l
	+ unmodifiableSet(T, :, Object\>, (, Set\<+TT\>) : \<Object, Set\<+TT\>, Set\<TT\>\l
	- get(T, :, Object\>, (, ListIterator\<+TT\>, int) : \<Object, ListIterator\<+TT\>, I)TT\l
	+ emptyMap(K, :, Object, void, :, Object\>, () : \<Object, Object, Map\<TK, TV\>\l
	 synchronizedList(T, :, Object\>, (, List\<TT\>, Object) : \<Object, List\<TT\>, Object, List\<TT\>\l
	+ copy(T, :, Object\>, (, List\<-TT\>, List\<+TT\>) : void\l
	+ checkedSet(E, :, Object\>, (, Set\<TE\>, Class\<TE\>) : \<Object, Set\<TE\>, Class\<TE\>, Set\<TE\>\l
	+ singleton(T, :, Object\>, (, T, T) : \<Object, \>(TT, Set\<TT\>\l
	+ synchronizedMap(K, :, Object, void, :, Object\>, (, Map\<TK, T, void\>) : \<Object, Object, Map\<TK, TV\>, Map\<TK, TV\>\l
	+ unmodifiableNavigableMap(K, :, Object, void, :, Object\>, (, NavigableMap\<TK, +, T, void\>) : \<Object, Object, NavigableMap\<TK, +TV\>, NavigableMap\<TK, TV\>\l
	 synchronizedSet(T, :, Object\>, (, Set\<TT\>, Object) : \<Object, Set\<TT\>, Object, Set\<TT\>\l
	+ max(T, :, Object\>, (, Collection\<+TT\>, Comparator\<-TT\>) : \<Object, Collection\<+TT\>, Comparator\<-TT\>, )TT\l
	+ singletonList(T, :, Object\>, (, T, T) : \<Object, \>(TT, List\<TT\>\l
	+ reverse(List\<*\>) : void\l
	 singletonSpliterator(T, :, Object\>, (, T, T) : \<Object, \>(TT, Spliterator\<TT\>\l
	+ checkedList(E, :, Object\>, (, List\<TE\>, Class\<TE\>) : \<Object, List\<TE\>, Class\<TE\>, List\<TE\>\l
	+ emptySortedMap(K, :, Object, void, :, Object\>, () : \<Object, Object, SortedMap\<TK, TV\>\l
	+ nCopies(T, :, Object\>, (, int, T, T) : \<Object, \>(ITT, List\<TT\>\l
	+ unmodifiableSortedMap(K, :, Object, void, :, Object\>, (, SortedMap\<TK, +, T, void\>) : \<Object, Object, SortedMap\<TK, +TV\>, SortedMap\<TK, TV\>\l
	+ emptyListIterator(T, :, Object\>, () : \<Object, ListIterator\<TT\>\l
	+ addAll(T, :, Object\>, (, Collection\<-TT\>, [], T, T) : boolean\l
	+ checkedQueue(E, :, Object\>, (, Queue\<TE\>, Class\<TE\>) : \<Object, Queue\<TE\>, Class\<TE\>, Queue\<TE\>\l
	+ emptySortedSet(E, :, Object\>, () : \<Object, SortedSet\<TE\>\l
	+ shuffle(List\<*\>, Random) : void\l
	+ unmodifiableSortedSet(T, :, Object\>, (, SortedSet\<TT\>) : \<Object, SortedSet\<TT\>, SortedSet\<TT\>\l
	}"
	]
}